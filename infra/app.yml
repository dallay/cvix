name: ${APP_NAME}
include:
  - ./common.yml
  - ./postgresql/postgresql-compose.yml
  - ./keycloak/keycloak-compose.yml
  - ./docker-socket-proxy/docker-socket-proxy-compose.yml

services:
  traefik:
    image: traefik:v3.0
    command:
      - --api.insecure=true
      - --providers.docker=true
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      # Enable access logs for debugging
      - --accesslog=true
      - --log.level=INFO
      # Enable ping endpoint for healthcheck
      - --ping=true
    ports:
      - "80:80"
      - "443:443"
      - "8090:8080"  # Traefik dashboard
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - frontend
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "traefik", "healthcheck", "--ping"]
      interval: 10s
      timeout: 5s
      retries: 3

  landing:
    image: ghcr.io/dallay/cvix-marketing:latest
    environment:
      # Public/front-facing URLs (used at build/runtime by the marketing image)
      PUBLIC_BASE_URL_PROD: ${PUBLIC_BASE_URL_PROD}
      PUBLIC_BASE_DOCS_URL_PROD: ${PUBLIC_BASE_DOCS_URL_PROD}
      PUBLIC_SITE_URL: ${PUBLIC_SITE_URL}
      PUBLIC_BASE_WEBAPP_URL_PROD: ${PUBLIC_BASE_WEBAPP_URL_PROD}

      # Node environment
      NODE_ENV: production
    labels:
      - "traefik.enable=true"
      # Use HTTP in local, TLS would be handled by reverse proxy in real prod
      - "traefik.http.routers.landing.rule=Host(`landing.localhost`)"
      - "traefik.http.routers.landing.entrypoints=web"
      # Nginx serves on port 8080 (non-privileged port for non-root user)
      - "traefik.http.services.landing.loadbalancer.server.port=8080"
    networks:
      - frontend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  frontend:
    image: ghcr.io/dallay/cvix-webapp:latest
    environment:
      # Frontend runtime configuration
      CVIX_API_URL: ${CVIX_API_URL}
      VITE_KEYCLOAK_URL: ${OAUTH2_SERVER_URL}
      VITE_KEYCLOAK_REALM: ${REALM}
      VITE_KEYCLOAK_CLIENT_ID: ${CLIENT_ID}

      # Public webapp URL
      PUBLIC_BASE_WEBAPP_URL_PROD: ${PUBLIC_BASE_WEBAPP_URL_PROD}

      # Node environment
      NODE_ENV: production

      # Caddy CSP configuration (runtime variables)
      # CRITICAL: Override these in staging/production to remove 'unsafe-inline'
      CSP_SCRIPT_SRC: ${CSP_SCRIPT_SRC:-'self' 'unsafe-inline'}
      CSP_STYLE_SRC: ${CSP_STYLE_SRC:-'self' 'unsafe-inline'}
      CSP_CONNECT_SRC: ${CSP_CONNECT_SRC:-'self'}
      CSP_OBJECT_SRC: ${CSP_OBJECT_SRC:-'none'}
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.frontend.rule=Host(`frontend.localhost`)"
      - "traefik.http.routers.frontend.entrypoints=web"
      # Nginx serves on port 8080 (non-privileged port for non-root user)
      - "traefik.http.services.frontend.loadbalancer.server.port=8080"
    networks:
      - frontend
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  backend:
    image: ghcr.io/dallay/cvix-engine:latest
    environment:
      # JVM Options for production-like setup
      JAVA_OPTS: >-
        -Xms512m
        -Xmx1024m
        -XX:+UseG1GC
        -XX:MaxGCPauseMillis=100
        -XX:+UseStringDeduplication
        -Djava.security.egd=file:/dev/./urandom

      # Database (R2DBC for reactive operations)
      DATABASE_URL: ${DATABASE_URL}
      DATABASE_USERNAME: ${DATABASE_USERNAME}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD}

      # Database (JDBC for Liquibase migrations - Dual Driver Strategy)
      # Liquibase requires JDBC driver, so we provide a separate JDBC URL
      LIQUIBASE_URL: ${LIQUIBASE_URL}

      # Spring profile / server URLs
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE}
      OAUTH2_SERVER_URL: ${OAUTH2_SERVER_URL}

      # Keycloak / Auth configuration
      REALM: ${REALM}
      CLIENT_ID: ${CLIENT_ID}
      # Point to secret file location
      CLIENT_SECRET_FILE: /run/secrets/client_secret

      # Admin / test helpers
      ADMIN_CLIENT_ID: ${ADMIN_CLIENT_ID}
      ADMIN_REALM: ${ADMIN_REALM}
      ADMIN_REALM_USERNAME: ${ADMIN_REALM_USERNAME}
      ADMIN_REALM_PASSWORD_FILE: /run/secrets/admin_realm_password

      # Keycloak host references
      KEYCLOAK_URL: ${KEYCLOAK_URL}
      KC_HOSTNAME: ${KC_HOSTNAME}

      # CORS configuration
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS}
      CORS_ALLOWED_METHODS: ${CORS_ALLOWED_METHODS}
      CORS_ALLOWED_HEADERS: ${CORS_ALLOWED_HEADERS}
      CORS_EXPOSED_HEADERS: ${CORS_EXPOSED_HEADERS}
      CORS_ALLOW_CREDENTIALS: ${CORS_ALLOW_CREDENTIALS}
      CORS_MAX_AGE: ${CORS_MAX_AGE}

      # Host & app-level flags
      HOSTNAME: ${HOSTNAME}
      PERSIST_LATEX_FILES: ${PERSIST_LATEX_FILES}

      # Email / Notification
      SENDGRID_API_KEY_FILE: /run/secrets/sendgrid_api_key
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USERNAME_FILE: /run/secrets/smtp_username
      SMTP_PASSWORD_FILE: /run/secrets/smtp_password
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME}

      # PDF Generation
      PDF_DOCKER_IMAGE: ${PDF_DOCKER_IMAGE}
      PDF_MAX_CONCURRENT_CONTAINERS: ${PDF_MAX_CONCURRENT_CONTAINERS}
      PDF_TIMEOUT_SECONDS: ${PDF_TIMEOUT_SECONDS}
      PDF_MEMORY_LIMIT_MB: ${PDF_MEMORY_LIMIT_MB}
      PDF_CPU_QUOTA: ${PDF_CPU_QUOTA}
      # Docker Socket Proxy configuration
      # Set to 'tcp://docker-socket-proxy:2375' to use the socket proxy
      # For local dev only, you can use 'unix:///var/run/docker.sock' (NOT RECOMMENDED FOR PRODUCTION)
      DOCKER_HOST: ${DOCKER_HOST:-tcp://docker-socket-proxy:2375}

      # SSL/TLS
      SSL_KEY_ALIAS: ${SSL_KEY_ALIAS}
      SSL_KEYSTORE_PASSWORD_FILE: /run/secrets/ssl_keystore_password
      SSL_KEYSTORE_LOCATION: ${SSL_KEYSTORE_LOCATION}

    secrets:
      - source: database_password
        target: DATABASE_PASSWORD
      - source: client_secret
        target: CLIENT_SECRET
      - source: admin_realm_password
        target: ADMIN_REALM_PASSWORD
      - source: sendgrid_api_key
        target: SENDGRID_API_KEY
      - source: smtp_username
        target: SMTP_USERNAME
      - source: smtp_password
        target: SMTP_PASSWORD
      - source: ssl_keystore_password
        target: SSL_KEYSTORE_PASSWORD
      - source: waitlist_ip_hmac_secret
        target: WAITLIST_IP_HMAC_SECRET

    volumes:
      # PRODUCTION WARNING: Direct Docker socket mounting is a CRITICAL security risk
      # ════════════════════════════════════════════════════════════════════════════
      # Mounting /var/run/docker.sock grants ROOT-LEVEL access to the host system.
      # Any compromise of this container means complete host compromise.
      #
      # RECOMMENDED APPROACH FOR PRODUCTION:
      # 1. Remove this volume mount entirely
      # 2. Configure DOCKER_HOST=tcp://docker-socket-proxy:2375 (see environment above)
      # 3. Use the included docker-socket-proxy service (Tecnativa Docker Socket Proxy)
      #    which whitelists ONLY these operations:
      #    - POST /containers/create (create LaTeX containers)
      #    - POST /containers/{id}/start (start containers)
      #    - POST /containers/{id}/wait (wait for completion)
      #    - DELETE /containers/{id} (cleanup)
      #    - GET /images/* (check if texlive image exists)
      #
      # LOCAL DEVELOPMENT ONLY: Direct socket mount for convenience
      # Comment out the line below and use docker-socket-proxy for ANY non-local env
      - /var/run/docker.sock:/var/run/docker.sock

      # Persist LaTeX output if enabled
      # NOTE: Use absolute paths or set working directory before running docker compose
      - ./data/latex:/app/latex-output

      # Application logs
      - ./logs/backend:/app/logs

      # SSL keystore (if using file-based)
      - ./ssl:/app/ssl:ro

    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.backend.rule=Host(`backend.localhost`)"
      - "traefik.http.routers.backend.entrypoints=web"
      - "traefik.http.services.backend.loadbalancer.server.port=8080"

    networks:
      - frontend
      - backend

    depends_on:
      postgresql:
        condition: service_healthy
      keycloak:
        condition: service_healthy

    restart: unless-stopped

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s

    # Resource limits for non-Swarm mode (docker compose)
    mem_limit: 2G
    mem_reservation: 512M
    cpus: 2.0

#
# Docker secrets definitions for sensitive values
# These secrets must be created and provisioned in your deployment pipeline or Docker Compose setup.
# Each secret will be mounted as a file in /run/secrets/SECRET_NAME inside the container.
# Ensure strict file permissions and access controls for any temporary secret files.
#
# Secrets are read by docker-entrypoint.sh at container startup and exported as environment variables.
# The entrypoint script expects secrets mounted at /run/secrets/SECRET_NAME (uppercase target names).
secrets:
  database_password:
    file: ./secrets/database_password.txt
  client_secret:
    file: ./secrets/client_secret.txt
  admin_realm_password:
    file: ./secrets/admin_realm_password.txt
  sendgrid_api_key:
    file: ./secrets/sendgrid_api_key.txt
  smtp_username:
    file: ./secrets/smtp_username.txt
  smtp_password:
    file: ./secrets/smtp_password.txt
  ssl_keystore_password:
    file: ./secrets/ssl_keystore_password.txt
  waitlist_ip_hmac_secret:
    file: ./secrets/waitlist_ip_hmac_secret.txt
