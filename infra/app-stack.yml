# ============================================================================
# Stack-compatible compose file for Docker Swarm / Dokploy
# ============================================================================
# IMPORTANT: This file uses named volumes instead of bind mounts because
# Docker Swarm does not support relative paths in bind mounts - the paths
# would need to exist on ALL nodes in the swarm cluster.
#
# Stack name is provided via: docker stack deploy -c app-stack.yml <stack-name>
# ============================================================================

services:
  # ========================================
  # PostgreSQL Database
  # ========================================
  postgresql:
    image: postgres:${POSTGRESQL_VERSION:-16.9-alpine}
    # Note: container_name is ignored in Stack mode (Swarm auto-generates names)
    environment:
      POSTGRES_USER: ${POSTGRESQL_USER}
      POSTGRES_PASSWORD: ${POSTGRESQL_PASSWORD}
      POSTGRES_DB: ${POSTGRESQL_DB}
    shm_size: 128mb
    ports:
      - '5432:5432'
    volumes:
      # Named volumes for Swarm compatibility
      - postgresql_data:/var/lib/postgresql/data
      # Note: init-scripts removed - use Liquibase migrations in backend instead
    networks:
      - backend
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRESQL_USER} -d ${POSTGRESQL_DB}"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # ========================================
  # Docker Socket Proxy
  # ========================================
  # Provides restricted access to Docker API for backend PDF generation
  # This is more secure than mounting the raw Docker socket
  docker-socket-proxy:
    image: tecnativa/docker-socket-proxy:0.2.0
    environment:
      # Disable all endpoints by default
      AUTH: 0
      SECRETS: 0
      POST: 1  # Required for creating containers
      BUILD: 0
      COMMIT: 0
      CONFIGS: 0
      CONTAINERS: 1  # Required for container operations
      DISTRIBUTION: 0
      EXEC: 0
      IMAGES: 1  # Required for pulling images
      INFO: 0
      NETWORKS: 0
      NODES: 0
      PING: 0
      PLUGINS: 0
      SERVICES: 0
      SESSION: 0
      SWARM: 0
      SYSTEM: 0
      TASKS: 0
      VOLUMES: 0
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    networks:
      - backend
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 128M
        reservations:
          cpus: '0.1'
          memory: 32M
    healthcheck:
      test: ["CMD", "nc", "-z", "127.0.0.1", "2375"]
      interval: 10s
      timeout: 5s
      retries: 3

  # ========================================
  # Frontend (Vue.js)
  # ========================================
  frontend:
    image: dallay/cvix-webapp:2.0.1-beta
    environment:
      # Nginx runtime configuration (required by docker-entrypoint.sh)
      # VITE_* variables are build-time only - they are baked into JS during build
      BACKEND_URL: ${BACKEND_URL}
      CSP_SCRIPT_SRC: ${CSP_SCRIPT_SRC:-'self' 'unsafe-inline'}
      CSP_STYLE_SRC: ${CSP_STYLE_SRC:-'self' 'unsafe-inline'}

    # Port exposed for Traefik routing
    expose:
      - 8080

    networks:
      - dokploy-network

    restart: unless-stopped

    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

    # Traefik labels for Dokploy routing
    # NOTE: Docker Swarm does NOT interpolate variables in deploy.labels!
    # Domains must be hardcoded here or use Traefik file provider.
    deploy:
      placement:
        constraints:
          - node.hostname == fenix-icloud
      
      labels:
        # Enable Traefik for this service
        - "traefik.enable=true"

        # HTTP Router (port 80)
        - "traefik.http.routers.cvix-frontend.rule=Host(`app.profiletailors.com`)"
        - "traefik.http.routers.cvix-frontend.entrypoints=web"
        - "traefik.http.routers.cvix-frontend.middlewares=redirect-to-https@docker"

        # HTTPS Router (port 443)
        - "traefik.http.routers.cvix-frontend-secure.rule=Host(`app.profiletailors.com`)"
        - "traefik.http.routers.cvix-frontend-secure.entrypoints=websecure"
        - "traefik.http.routers.cvix-frontend-secure.tls=true"
        - "traefik.http.routers.cvix-frontend-secure.tls.certresolver=letsencrypt"

        # Service configuration
        - "traefik.http.services.cvix-frontend.loadbalancer.server.port=8080"

        # Security headers middleware (use @swarm since services are deployed via Docker Swarm)
        - "traefik.http.middlewares.cvix-frontend-headers.headers.customFrameOptionsValue=SAMEORIGIN"
        - "traefik.http.middlewares.cvix-frontend-headers.headers.stsSeconds=31536000"
        - "traefik.http.middlewares.cvix-frontend-headers.headers.stsIncludeSubdomains=true"
        - "traefik.http.middlewares.cvix-frontend-headers.headers.stsPreload=true"
        - "traefik.http.routers.cvix-frontend-secure.middlewares=cvix-frontend-headers@swarm"

      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M

  backend:
    image: dallay/cvix-engine:2.0.1-beta
    environment:
      # JVM Options for production-like setup
      JAVA_OPTS: >-
        -Xms512m
        -Xmx1024m
        -XX:+UseG1GC
        -XX:MaxGCPauseMillis=100
        -XX:+UseStringDeduplication
        -Djava.security.egd=file:/dev/./urandom

      # Database (R2DBC)
      DATABASE_URL: ${DATABASE_URL}
      DATABASE_USERNAME: ${DATABASE_USERNAME}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD}

      # Spring profile / server URLs
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE}
      OAUTH2_SERVER_URL: ${OAUTH2_SERVER_URL}

      # Keycloak / Auth configuration
      REALM: ${REALM}
      CLIENT_ID: ${CLIENT_ID}
      # Point to secret file location (Docker mounts with target name in UPPERCASE)
      CLIENT_SECRET_FILE: /run/secrets/CLIENT_SECRET

      # Admin / test helpers
      ADMIN_CLIENT_ID: ${ADMIN_CLIENT_ID}
      ADMIN_REALM: ${ADMIN_REALM}
      ADMIN_REALM_USERNAME: ${ADMIN_REALM_USERNAME}
      ADMIN_REALM_PASSWORD_FILE: /run/secrets/ADMIN_REALM_PASSWORD

      # Keycloak host references
      KEYCLOAK_URL: ${KEYCLOAK_URL}
      KC_HOSTNAME: ${KC_HOSTNAME}

      # CORS configuration
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS}
      CORS_ALLOWED_METHODS: ${CORS_ALLOWED_METHODS}
      CORS_ALLOWED_HEADERS: ${CORS_ALLOWED_HEADERS}
      CORS_EXPOSED_HEADERS: ${CORS_EXPOSED_HEADERS}
      CORS_ALLOW_CREDENTIALS: ${CORS_ALLOW_CREDENTIALS}
      CORS_MAX_AGE: ${CORS_MAX_AGE}

      # Host & app-level flags
      HOSTNAME: ${HOSTNAME}
      PERSIST_LATEX_FILES: ${PERSIST_LATEX_FILES}

      # Email / Notification
      SENDGRID_API_KEY_FILE: /run/secrets/SENDGRID_API_KEY
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      SMTP_USERNAME_FILE: /run/secrets/SMTP_USERNAME
      SMTP_PASSWORD_FILE: /run/secrets/SMTP_PASSWORD
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME}

      # PDF Generation
      PDF_DOCKER_IMAGE: ${PDF_DOCKER_IMAGE}
      PDF_MAX_CONCURRENT_CONTAINERS: ${PDF_MAX_CONCURRENT_CONTAINERS}
      PDF_TIMEOUT_SECONDS: ${PDF_TIMEOUT_SECONDS}
      PDF_MEMORY_LIMIT_MB: ${PDF_MEMORY_LIMIT_MB}
      PDF_CPU_QUOTA: ${PDF_CPU_QUOTA}

      # SSL/TLS
      SSL_KEY_ALIAS: ${SSL_KEY_ALIAS}
      SSL_KEYSTORE_PASSWORD_FILE: /run/secrets/SSL_KEYSTORE_PASSWORD
      SSL_KEYSTORE_LOCATION: ${SSL_KEYSTORE_LOCATION}

      # Docker Socket Proxy for PDF generation (secure remote Docker API)
      DOCKER_HOST: tcp://docker-socket-proxy:2375
      WAITLIST_IP_HMAC_SECRET: /run/secrets/WAITLIST_IP_HMAC_SECRET

    secrets:
      - source: client_secret
        target: CLIENT_SECRET
      - source: admin_realm_password
        target: ADMIN_REALM_PASSWORD
      - source: sendgrid_api_key
        target: SENDGRID_API_KEY
      - source: smtp_username
        target: SMTP_USERNAME
      - source: smtp_password
        target: SMTP_PASSWORD
      - source: ssl_keystore_password
        target: SSL_KEYSTORE_PASSWORD
      - source: waitlist_ip_hmac_secret
        target: WAITLIST_IP_HMAC_SECRET

    volumes:
      # Named volumes for Swarm compatibility
      # LaTeX output files (if PERSIST_LATEX_FILES=true)
      - latex_output:/app/latex-output
      # Application logs
      - backend_logs:/app/logs

    # Port exposed for Traefik routing (configured via Dokploy UI)
    expose:
      - 8080

    networks:
      - dokploy-network
      - backend

    # Stack mode uses simple depends_on (no condition support)
    # PostgreSQL healthcheck ensures it's ready before backend starts
    depends_on:
      - postgresql
      - docker-socket-proxy

    restart: unless-stopped

    healthcheck:
      test: ["CMD-SHELL", "bash -c 'echo > /dev/tcp/localhost/8080' || exit 1"]
      interval: 60s
      timeout: 30s
      retries: 10
      start_period: 120s

    # Resource limits and Traefik labels
    # NOTE: Docker Swarm does NOT interpolate variables in deploy.labels!
    # Domains must be hardcoded here or use Traefik file provider.
    deploy:
      placement:
        constraints:
          - node.hostname == fenix-icloud
      
      labels:
        # Enable Traefik for this service
        - "traefik.enable=true"

        # HTTP Router (port 80)
        - "traefik.http.routers.cvix-backend.rule=Host(`api.profiletailors.com`)"
        - "traefik.http.routers.cvix-backend.entrypoints=web"
        - "traefik.http.routers.cvix-backend.middlewares=redirect-to-https@docker"

        # HTTPS Router (port 443)
        - "traefik.http.routers.cvix-backend-secure.rule=Host(`api.profiletailors.com`)"
        - "traefik.http.routers.cvix-backend-secure.entrypoints=websecure"
        - "traefik.http.routers.cvix-backend-secure.tls=true"
        - "traefik.http.routers.cvix-backend-secure.tls.certresolver=letsencrypt"

        # Service configuration
        - "traefik.http.services.cvix-backend.loadbalancer.server.port=8080"

        # Security headers middleware (use @swarm since services are deployed via Docker Swarm)
        - "traefik.http.middlewares.cvix-backend-headers.headers.customFrameOptionsValue=SAMEORIGIN"
        - "traefik.http.middlewares.cvix-backend-headers.headers.stsSeconds=31536000"
        - "traefik.http.middlewares.cvix-backend-headers.headers.stsIncludeSubdomains=true"
        - "traefik.http.middlewares.cvix-backend-headers.headers.stsPreload=true"
        - "traefik.http.routers.cvix-backend-secure.middlewares=cvix-backend-headers@swarm"

        # Rate limiting (optional but recommended for APIs)
        - "traefik.http.middlewares.cvix-backend-ratelimit.ratelimit.average=100"
        - "traefik.http.middlewares.cvix-backend-ratelimit.ratelimit.burst=50"

      resources:
        limits:
          cpus: '2.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 512M

# ============================================================================
# Docker Secrets Configuration
# ============================================================================
# These secrets must be created in Dokploy BEFORE deployment.
# They are marked as 'external: true' meaning Docker expects them to already exist.
#
# Create them via Dokploy UI (Settings â†’ Secrets) or via CLI:
#   docker secret create client_secret <(echo -n "your-secret-value")
#
# The 'name' field specifies the exact name Docker will look for.
# ============================================================================
secrets:
  client_secret:
    external: true
    name: client_secret

  admin_realm_password:
    external: true
    name: admin_realm_password

  sendgrid_api_key:
    external: true
    name: sendgrid_api_key

  smtp_username:
    external: true
    name: smtp_username

  smtp_password:
    external: true
    name: smtp_password

  ssl_keystore_password:
    external: true
    name: ssl_keystore_password

  waitlist_ip_hmac_secret:
    external: true
    name: waitlist_ip_hmac_secret

# ============================================================================
# Networks Configuration
# ============================================================================
networks:
  # External network managed by Dokploy for Traefik routing
  dokploy-network:
    external: true

  # Internal network for backend-database communication
  backend:

# ============================================================================
# Named Volumes Configuration
# ============================================================================
# Named volumes are required for Docker Swarm because bind mounts with
# relative paths don't work - the paths would need to exist on ALL nodes.
# These volumes are automatically created and managed by Docker.
# ============================================================================
volumes:
  # PostgreSQL data persistence
  postgresql_data:

  # Backend application logs
  backend_logs:

  # LaTeX output files for PDF generation
  latex_output:
