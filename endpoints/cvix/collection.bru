meta {
  name: ProFileTailors
}

headers {
  X-XSRF-TOKEN: {{xsrfToken}}
}

auth {
  mode: oauth2
}

auth:oauth2 {
  grant_type: authorization_code
  callback_url: http://localhost:8080
  authorization_url: {{keycloak-url}}/realms/{{realm}}/protocol/openid-connect/auth
  access_token_url: {{keycloak-url}}/realms/{{realm}}/protocol/openid-connect/token
  refresh_token_url: 
  client_id: {{clientId}}
  client_secret: {{clientSecret}}
  scope: {{scope}}
  state: 
  pkce: false
  credentials_placement: basic_auth_header
  credentials_id: credentials
  token_placement: header
  token_header_prefix: Bearer
  auto_fetch_token: true
  auto_refresh_token: false
}

vars:pre-request {
  url: http://localhost:8080
  realm: cvix
  workspaceId: 44130a13-029f-352a-a6a2-b318640aecec
  formId: f77a00fc-778c-4703-8c33-1fde0bc6437b
  tagId: 4ff98e9d-7f48-48af-96a0-221650e05084
  xsrfToken: oq__v5VvI3cPz_KKhZnmSYz_-M2_6VGg4BnUazKAJpsGcVOhl5ue2aNaF0Qi95Pr4bTSfLTM1fSM3zCN1CDjUgrhHv9gFTXD
  locale: en
}

script:pre-request {
  // ðŸ”§ Global CSRF Script - Runs before each request
  // Ensures the XSRF-TOKEN cookie is sent automatically
  
  const xsrfToken = bru.getEnvVar('xsrfToken');
  const url = bru.getEnvVar('url');
  
  if (xsrfToken && url) {
    // Force the cookie to be in the Cookie Jar for each request
    const jar = bru.cookies.jar();
    jar.setCookie(url, 'XSRF-TOKEN', xsrfToken);
  }
}

script:post-response {
  // ðŸ”§ Global CSRF Script - Runs after each response
  // Automatically updates the token if the server sends a new one
  
  const url = bru.getEnvVar('url');
  const jar = bru.cookies.jar();
  
  // If the server sent a new XSRF-TOKEN cookie, update it
  jar.getCookie(url, 'XSRF-TOKEN').then(cookie => {
    if (cookie && cookie.value) {
      const currentToken = bru.getEnvVar('xsrfToken');
  
      // Only update if it's different from the current one
      if (currentToken !== cookie.value) {
        bru.setEnvVar('xsrfToken', cookie.value);
        console.log('ðŸ”„ CSRF token updated automatically');
      }
    }
  }).catch(() => {
    // Silence errors to not pollute logs of normal requests
  });
}
