name: ${APP_NAME}
include:
  - ./common.yml
  - ./postgresql/postgresql-compose.yml
  - ./keycloak/keycloak-compose.yml
services:
  traefik:
    image: traefik:v3.0
    command:
      - --api.insecure=true
      - --providers.docker=true
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - frontend
      - backend

  landing:
    image: ghcr.io/dallay/cvix/marketing:main
    environment:
      # Public/front-facing URLs (used at build/runtime by the marketing image)
      PUBLIC_BASE_URL_PROD: ${PUBLIC_BASE_URL_PROD}
      PUBLIC_BASE_DOCS_URL_PROD: ${PUBLIC_BASE_DOCS_URL_PROD}
      PUBLIC_SITE_URL: ${PUBLIC_SITE_URL}
      PUBLIC_BASE_WEBAPP_URL_PROD: ${PUBLIC_BASE_WEBAPP_URL_PROD}
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.landing.rule=Host(`landing.localhost`)"
      - "traefik.http.routers.landing.entrypoints=websecure"
      - "traefik.http.services.landing.loadbalancer.server.port=443"
    networks:
      - frontend

  frontend:
    image: ghcr.io/dallay/cvix/webapp:main
    environment:
      # Frontend runtime configuration
      BACKEND_URL: ${BACKEND_URL}
      # Optional: public url for the webapp if needed by the image
      PUBLIC_BASE_WEBAPP_URL_PROD: ${PUBLIC_BASE_WEBAPP_URL_PROD}
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.frontend.rule=Host(`frontend.localhost`)"
      - "traefik.http.routers.frontend.entrypoints=web"
      - "traefik.http.services.frontend.loadbalancer.server.port=80"
    networks:
      - frontend

  backend:
    image: ghcr.io/dallay/cvix/engine:main
    environment:
      # Database (R2DBC)
      DATABASE_URL: ${DATABASE_URL}
      DATABASE_USERNAME: ${DATABASE_USERNAME}
      DATABASE_PASSWORD: ${DATABASE_PASSWORD}

      # Spring profile / server URLs
      SPRING_PROFILES_ACTIVE: ${SPRING_PROFILES_ACTIVE}
      OAUTH2_SERVER_URL: ${OAUTH2_SERVER_URL}

      # Keycloak / Auth configuration
      # Realm and client used by the application to validate tokens
      REALM: ${REALM}
      CLIENT_ID: ${CLIENT_ID}
      # CLIENT_SECRET is now provided via Docker secret (see secrets: block below)

      # Admin / test helpers (admin realm client used by infra tasks/tests)
      ADMIN_CLIENT_ID: ${ADMIN_CLIENT_ID}
      ADMIN_REALM: ${ADMIN_REALM}
      ADMIN_REALM_USERNAME: ${ADMIN_REALM_USERNAME}
      # ADMIN_REALM_PASSWORD is now provided via Docker secret (see secrets: block below)

      # Keycloak host references (docker/compose integration)
      KEYCLOAK_URL: ${KEYCLOAK_URL}
      KC_HOSTNAME: ${KC_HOSTNAME}

      # CORS configuration (comma-separated values supported)
      CORS_ALLOWED_ORIGINS: ${CORS_ALLOWED_ORIGINS}
      CORS_ALLOWED_METHODS: ${CORS_ALLOWED_METHODS}
      CORS_ALLOWED_HEADERS: ${CORS_ALLOWED_HEADERS}
      CORS_EXPOSED_HEADERS: ${CORS_EXPOSED_HEADERS}
      CORS_ALLOW_CREDENTIALS: ${CORS_ALLOW_CREDENTIALS}
      CORS_MAX_AGE: ${CORS_MAX_AGE}

      # Host & app-level flags
      HOSTNAME: ${HOSTNAME}
      PERSIST_LATEX_FILES: ${PERSIST_LATEX_FILES}

      # Email / Notification (development & production)
      # SENDGRID_API_KEY is now provided via Docker secret (see secrets: block below)
      SMTP_HOST: ${SMTP_HOST}
      SMTP_PORT: ${SMTP_PORT}
      # SMTP_USERNAME and SMTP_PASSWORD are now provided via Docker secrets (see secrets: block below)
      SMTP_FROM_EMAIL: ${SMTP_FROM_EMAIL}
      SMTP_FROM_NAME: ${SMTP_FROM_NAME}

      # PDF Generation (resume/document rendering)
      PDF_DOCKER_IMAGE: ${PDF_DOCKER_IMAGE}
      PDF_MAX_CONCURRENT_CONTAINERS: ${PDF_MAX_CONCURRENT_CONTAINERS}
      PDF_TIMEOUT_SECONDS: ${PDF_TIMEOUT_SECONDS}
      PDF_MEMORY_LIMIT_MB: ${PDF_MEMORY_LIMIT_MB}
      PDF_CPU_QUOTA: ${PDF_CPU_QUOTA}

      # Optional SSL/keystore references (if your image uses them)
      SSL_KEY_ALIAS: ${SSL_KEY_ALIAS}
      # SSL_KEYSTORE_PASSWORD is now provided via Docker secret (see secrets: block below)
      SSL_KEYSTORE_LOCATION: ${SSL_KEYSTORE_LOCATION}

    secrets:
      - client_secret
      - admin_realm_password
      - sendgrid_api_key
      - smtp_username
      - smtp_password
      - ssl_keystore_password
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.backend.rule=Host(`backend.localhost`)"
      - "traefik.http.routers.backend.entrypoints=web"
      - "traefik.http.services.backend.loadbalancer.server.port=8080"
    networks:
      - frontend
      - backend

#
# Docker secrets definitions for sensitive values
# These secrets must be created and provisioned in your deployment pipeline or Docker Compose setup.
# Each secret will be mounted as a file in /run/secrets/SECRET_NAME inside the container.
# Ensure strict file permissions and access controls for any temporary secret files.
secrets:
  client_secret:
    file: ./secrets/client_secret.txt
  admin_realm_password:
    file: ./secrets/admin_realm_password.txt
  sendgrid_api_key:
    file: ./secrets/sendgrid_api_key.txt
  smtp_username:
    file: ./secrets/smtp_username.txt
  smtp_password:
    file: ./secrets/smtp_password.txt
  ssl_keystore_password:
    file: ./secrets/ssl_keystore_password.txt
