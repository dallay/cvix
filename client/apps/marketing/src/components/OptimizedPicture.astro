---
import {
	type LocalImageProps,
	Picture,
	type RemoteImageProps,
} from "astro:assets";
import type { ImageOutputFormat } from "astro";
import type { HTMLAttributes } from "astro/types";

type Props = (LocalImageProps | RemoteImageProps) & {
	formats?: ImageOutputFormat[];
	fallbackFormat?: ImageOutputFormat;
	pictureAttributes?: HTMLAttributes<"picture">;
	class?: string | null;
	/** Fallback image URL to use when the primary image fails to load */
	fallbackSrc?: string;
};

const {
	formats = ["avif", "webp"],
	fallbackFormat = "avif",
	// Use undefined as the default so the prop is omitted when not explicitly set.
	// Some runtimes/types include 'auto' for loading, but Astro's Picture
	// typing expects 'eager' | 'lazy' | null | undefined. Default to undefined
	// and map 'auto' below to avoid type errors.
	loading = undefined,
	fetchpriority = "auto",
	class: className = "mx-auto w-full max-w-full rounded-lg",
	fallbackSrc,
	...props
} = Astro.props;

// Normalize loading to the narrower set accepted by Astro's Picture.
// Read the raw prop in a permissive way so we can handle 'auto' when present
// without causing a TypeScript incompatible comparison.
const rawLoading =
	((Astro.props as unknown as Record<string, unknown>).loading as
		| string
		| undefined) ?? loading;
const picLoading: "eager" | "lazy" | null | undefined =
	rawLoading === "auto"
		? undefined
		: (rawLoading as "eager" | "lazy" | null | undefined);

// Generate unique ID for fallback handling (only when fallback is provided)
const wrapperId = fallbackSrc ? `img-wrapper-${crypto.randomUUID()}` : undefined;
---

<div id={wrapperId} data-fallback-src={fallbackSrc} class="contents">
	<Picture
		{...props}
		formats={formats}
		fallbackFormat={fallbackFormat}
		loading={picLoading}
		fetchpriority={fetchpriority}
		class={className}
	/>
</div>

{fallbackSrc && (
	<script>
		// Handle image fallback - runs once per component instance
		(function initImageFallback() {
			const wrappers = document.querySelectorAll('[data-fallback-src]');
			
			wrappers.forEach((wrapper) => {
				if (wrapper.hasAttribute('data-fallback-initialized')) return;
				wrapper.setAttribute('data-fallback-initialized', 'true');
				
				const fallbackUrl = wrapper.getAttribute('data-fallback-src');
				if (!fallbackUrl) return;

				const img = wrapper.querySelector('img');
				if (!img) return;

				// Set fallback image on error
				img.addEventListener('error', function handleImageError() {
					// Prevent infinite loop if fallback also fails
					if (this.src !== fallbackUrl && !this.dataset.fallbackFailed) {
						this.src = fallbackUrl;
						this.dataset.fallbackFailed = 'true';
					}
				}, { once: true });
			});
		})();
	</script>
)}
